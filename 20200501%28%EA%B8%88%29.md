1. 학습 날짜 // 

    2020-05-01(금)

2. 학습시간 // 

    12:00 ~ 14:00, 22:00 ~ 24:00(자가)

3. 학습 범위 및 주제 // 
    
    정렬 알고리즘

4. 동료 학습 방법 (온라인 또는 오프라인으로 동료 학습이 이뤄진 경우, 어떤 식으로 이뤄졌는지 기술) // 오프라인으로 만난경우 각각 슬랙 아이디 // 온라인(슬랙, 스카이프, 카카오톡)으로 피드백을 받는 경우 피드백해준 자 ID // 

    온라인을 통해 동료학습 함. 카카오톡 단체 채팅방과 슬랙 random 채널을 이용하여 모르는 부분에 대해 질문하고 답을 얻음. 피드백해준 자 :gicho, jeonkim, sanhan, jungtlee, youcho, sanglee

5. 학습 목표 //

    정렬 알고리즘에 대해 학습한다.
    
6. 과제 제출 repository 주소 // 
    
    
    
7. 상세 학습 내용 (운영진 판단하에 학습 내용이 부진할 경우 재 제출 요구 예정) 필수사항 이외에 자유롭게 작성 가능 실제 코딩에 사용한 시간 (필수) 학습에 참고한 사이트 (홈페이지, 블로그, 동영상, 자료)와 간단한 내용(권고) 오늘 발견한 문제(버그, 몰랐던 것,...)와 해결 방안(필수) 다른 교육생들과의 협업, 토론 내용(권고) //
    
    23:00 ~ 24:00 동안 연습문제를 풀며 코드를 작성하였다. 다양한 정렬 알고리즘을 학습하였다. 선택정렬, 삽입정렬, 버블정렬, 힙정렬, 특수 정렬에 대해 알게 되었다. 
    
    선택정렬은 값이 가장 큰 자료를 선택하고, 선택한 자료와 가장 오른쪽 자료를 교환하고, 가장 오른쪽 자료를 제외한 나머지에서 위 과정을 반복하여 정렬을 수행한다. 선택 정렬은 입력 데이터에 민감하지 못하여 어떤 입력이 들어오던 O(n^2)의 시간복잡도를 갖는다. 
    
    버블정렬은 오른쪽 인접 자료와 크기를 비교하고, 현 위치 자료가 더 큰 경우 서로 위치를 교환하고, 한 칸씩 우측으로 이동하며 가장 큰 자료가 가장 오른쪽에 위치하도록 한다. 이후 정렬된 자료를 제외하고 위 과정을 반복하여 정렬을 수행한다. 버블정렬도 입력 데이터에 민감하지 못하며 O(n^2)의 시간복잡도를 갖는다. 또한 선택정렬에 비해 교환횟수가 많은 특징이 있다. 
    
    삽입 정렬은 정렬대상은 1개 부터 점점 늘려가며 정렬을 수행한다. 삽입할 자료와 가장 우측 자료를 비교하여 비교자료가 더 큰 경우 우측으로 이동시키고 비교자료가 작거나 같은 경우 해당위치에 삽입할 자료를 배치한다. 삽입할 자료가 배치될때까지 좌측으로 이동하며 비교를 하고, 비교 대상 자료의 크기를 하나씩 늘려가며 위 과정을 반복하여 정렬을 수행한다. 삽입정렬의 경우 입력 데이터에 따라 수행시간이 달라지며 평균적으로 선택정렬과 버블정렬의 수행시간의 반정도가 걸리나 시간복잡도는 O(n^2)으로 동일하다. (참고 사이트 : https://gmlwjd9405.github.io/2018/05/06/algorithm-insertion-sort.html)
    
    힙정렬은 힙구조를 사용하여 정렬 수행시간을 단축한 알고리즘이며 힙구조는 1)complete binary tree 2)최소 힙의 경우 각 노드는 자식노드 값보다 크지 않음 이라는 특징을 만족하는 구조를 말한다. 최소 힙이란 루트에 데이터의 최소값이 있는 경우를, 최대 힙이란 루트에 데이터의최대값이 있는 경우를 말한다. 힙정렬은 힙 구조를 만든 후 루트와 비정렬 마지막 노드 교환 및 힙하강을 반복하며 정렬을 수행한다. (참고 사이트 : https://m.blog.naver.com/withham1/220976203490)
    
    
8. 학습 내용에 대한 개인적인 총평 (최소 5줄 이상) //
   
   선태정렬과 버블정렬의 경우 이미 알고 있던 내용이라 이해하는대 어려움이 없었다. 하지만 정렬 방법과 코드 구현에 대해서만 알고 있었고 해당 정렬이 갖는 장점이나 단점은 잘 모르고 있던 상태여서 해당 정렬에 대해 학습하면서 시간복잡도, 장단점에 대해 다시 익히는 기회였다. 삽입정렬과 힙정렬의 경우 기존에 알지 못하던 내용이라 새로운 정렬 방식에 대해 배울수 있었다. 삽입정렬의 경우 인접 데이터와 크기비교를 하며 자리를 바꾸는 것이 버블정렬과 유사하다고 느껴지기도 했다. 힙정렬은 트리구조를 이용한 정렬방식으로 완전히 새로웠고 힙을 만들고 힙하강을 통해 정렬한다는 방식을 이해하는대 시간이 필요했다. 트리구조의 특징을 이용해 정렬을 하는 것으로 시간복잡도를 nlogn 수준으로 줄일 수 있었고 알고리즘 문제에서 이용해 보면 좋을것 같았다. 힙정렬의 개념은 책을 반복해서 읽으면서 완전히 이해할 수 있었지만 힙정렬을 표현한 의사코드를 보면서 코드를 구현하는 것이 조금 까다롭게 느껴졌다. 반복적인 연습이 필요할 것 같았다.
   
9. 다음 학습 계획 (최소 5줄 이상) // 
    
    42seoul 과제 이외에 개인적으로 알고리즘, 자료구조에 대해 학습한다.
    
    알고리즘 연습문제를 풀며 학습한다.
    
    ft_printf 코드를 수정하고 평가를 받는다.
    