1. 학습 날짜 // 

    2020-04-22(수)

2. 학습시간 // 

    18:00 ~ 23:00(강남역 카페)

3. 학습 범위 및 주제 // 
    
    c++, new/delete 오버로딩, 스마트 포인터, 펑터

4. 동료 학습 방법 (온라인 또는 오프라인으로 동료 학습이 이뤄진 경우, 어떤 식으로 이뤄졌는지 기술) // 오프라인으로 만난경우 각각 슬랙 아이디 // 온라인(슬랙, 스카이프, 카카오톡)으로 피드백을 받는 경우 피드백해준 자 ID // 

    온라인을 통해 동료학습 함. 카카오톡 단체 채팅방과 슬랙 random 채널을 이용하여 모르는 부분에 대해 질문하고 답을 얻음. 피드백해준 자 :gicho, jeonkim, sanhan, jungtlee, youcho, sanglee

5. 학습 목표 //

    c++ new, delete 연산자 오버로딩 및 스마트포인터 와 펑터에 대해 학습한다.
    
6. 과제 제출 repository 주소 // 
    
    
    
7. 상세 학습 내용 (운영진 판단하에 학습 내용이 부진할 경우 재 제출 요구 예정) 필수사항 이외에 자유롭게 작성 가능 실제 코딩에 사용한 시간 (필수) 학습에 참고한 사이트 (홈페이지, 블로그, 동영상, 자료)와 간단한 내용(권고) 오늘 발견한 문제(버그, 몰랐던 것,...)와 해결 방안(필수) 다른 교육생들과의 협업, 토론 내용(권고) //

    18:00 ~ 19:00 동안 학습내용과 관련된 연습문제를 풀며 코드를 작성하였다. 
    c++에서 추가된 new와 delete도 연산자의 일종으로 오버로딩이 가능한 것을 알았다. new의 경우 1)메모리 공간할당 2)생성자 호출 3)자료형에 맞게 반환된 주소 값의 형변환 3가지 기능을 하는대 이 중에서 메모리 공간할당에 대한 부분에서만 오버로딩이 가능했다. 또한 오버로딩 하는 경우에도 기본적으로 갖추어야할 틀이 정해져 있어 제한적으로 오버로딩이 가능했다.
    
    new 연산자가 클래스에 멤버함수 형태로 오버로딩 된 경우 객체 생성 이후에 멤버함수 호출이 가능한대 new는 객체 생성시 사용하는 연산자로 이것이 어떻게 가능하냐는 질문이 있었다. 이에 대해 처음 객체를 생성할 때에는 컴파일러가 알아서 기본 형식에 의해 연산자를 사용하지 않을까라고 생각해 보았고 실제로는 operator new와 operator delete는 static 함수이며 객체 생성여부와 관계없이 메모리에 존재하기 때문에 객체 생성 전에도 사용가능하다는 것을 알게 되었다.
    
    스마트 포인터의 경우 기존의 포인터 연산자 처럼 동작하는 새로운 객체라는 것을 알았다. 스마트 포인터는 객체이므로 사용자가 직접 원하는 내용을 추가하여 포인터 연산자 처럼 동작하게 구현하는 것이 특징이었다. 일반 포인터와 달리 객체 소멸을 위한 delete 연산을 알아서 해주는 등의 특징을 가지고 있었다.
    
    함수의 매개변수를 전달하기 위해 사용하는 괄호 () 역시 연산자의 일종으로 오버로딩이 가능하다는 것을 알았다. () 연산자 오버로딩을 통해 객체가 마치 함수인것 처럼 작동하도록 만들 수 있었고 이를 펑터라고 불렀다. 펑터를 사용하는 이점으로 클래스의 상속을 이용하여 함수를 정의가능하다는 것이 있었다. 
    
8. 학습 내용에 대한 개인적인 총평 (최소 5줄 이상) //
    
    처음 new와 delete에 대해 배웠을때 c의 malloc과 같이 함수라고 생각하였고 정보를 찾아보기 위해 new 함수를 검색하였으나 결과가 나오지 않았다. 알고보니 함수가 아닌 연산자라는 것을 알게 되었고 그 이후 new와 delete를 연산자라고 생각하고 있었으나 오버로딩을 한다는 생각을 전혀 하지 못하고 있었다. 하지만 이번 기회를 통해 new와 delete의 경우 일반 연산자와 달리 복잡한 기능을 하므로 조금 제한적이지만 똑같은 연산자이므로 오버로딩이 가능하다는 것을 알게 되었다. 오버로딩을 위한 형식은 void ＊ operator new (size_t size) {...} 와 같이 이루어졌고 void형 포인터를 사용하는 부분은 이전 libft에서 연결리스트 관련된 함수코드를 작성하며 접한 내용이라 이해가 쉬웠다.
    
    포인터 연산자 ->을 오버로딩하는 함수에서 반환형이 return this; 와 같이 객체의 주소값을 반환하도록 되어있었다. 지금까지 ->는 ＊(변수). 과 같다고만 생각하였는대 반환형이 주소값이면 ptr->func(); 처럼 주소값에 이어서 바로 멤버함수를 쓸 수 있는게 조금 어색하게 느껴졌다.
    
    펑터의 경우 클래스의 상속을 이용하여 공통의 특징을 여러가지 함수를 정의할 수 있었고 이를 한번에 다룰수 있었다. 이것을 보며 함수포인터와 유사하다는 생각을 하였고 펑터를 통해 유용한 기능을 구현할 수 있을 것으로 생각되어 사용에 익숙해지면 좋을것 같다고 느꼈다.
    
9. 다음 학습 계획 (최소 5줄 이상) // 
    
    42seoul 과제 이외에 개인적으로 c++, 알고리즘, 자료구조에 대해 학습한다.
    
    알고리즘 연습문제를 풀며 학습한다.
    
    ft_printf 코드를 수정하고 평가를 받는다.
    