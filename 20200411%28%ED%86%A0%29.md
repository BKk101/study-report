1. 학습 날짜 // 

    2020-04-11(토)

2. 학습시간 // 

    13:00 ~ 17:00, 19:00 ~ 21:00 (자가)

3. 학습 범위 및 주제 // 
    
    c++, 대입연산자, 배열 인덱스 연산자 오버로딩

4. 동료 학습 방법 (온라인 또는 오프라인으로 동료 학습이 이뤄진 경우, 어떤 식으로 이뤄졌는지 기술) // 오프라인으로 만난경우 각각 슬랙 아이디 // 온라인(슬랙, 스카이프, 카카오톡)으로 피드백을 받는 경우 피드백해준 자 ID // 

    온라인을 통해 동료학습 함. 카카오톡 단체 채팅방과 슬랙 random 채널을 이용하여 모르는 부분에 대해 질문하고 답을 얻음. 피드백해준 자 :gicho, jeonkim, sanhan, jungtlee, youcho, sanglee

5. 학습 목표 //

    증감 연산자에 이어 대입연산자와 배열 인덱스 연산자 오버로딩에 대해 학습한다.
    
6. 과제 제출 repository 주소 // 
    
    gits@git.innovationacademy.kr:bykim/cpp.git
    
7. 상세 학습 내용 (운영진 판단하에 학습 내용이 부진할 경우 재 제출 요구 예정) 필수사항 이외에 자유롭게 작성 가능 실제 코딩에 사용한 시간 (필수) 학습에 참고한 사이트 (홈페이지, 블로그, 동영상, 자료)와 간단한 내용(권고) 오늘 발견한 문제(버그, 몰랐던 것,...)와 해결 방안(필수) 다른 교육생들과의 협업, 토론 내용(권고) //

    19:00 ~ 21:00 동안 연습문제를 풀며 코드를 작성하였다.
    복사 생성자와 유사한 대입연산자에 대해 알았다. 복사 생성자와 대입연산자는 호출 시점에 있어서 차이가 있으며 한줄에서 선언과 동시에 초기화를 하는 경우, 복사 생성자가 호출되고 이미 선언 및 초기화가 된 객체간 대입연산을 진행할 때 대입연산자가 호출된다. 대입연산자를 명시적으로 추가해 주지 않은 경우에 디폴트 대입연산자가 자동으로 추가되어 대입연산을 가능하게 해주었다. 이때 대입연산자의 반환형이 참조형으로 되어 있어 obj1 = obj2 = obj3; 와 같은 연산을 가능하게 해주었다. 대입연산자도 복사생성자와 같이 깊은복사/얕은 복사로 인한 문제가 발생하여 동적할당을 새롭게 해주어야 하는 경우가 존재하고 메모리 누수를 방지하기 위해 메모리 해제를 추가해 주어야 하는 경우가 존재했다. 상속구조에서는 대입연산자를 따로 정의한 경우, 기초클래스의 대입연산자 호출을 따로 명시해 주어야 기초클래스의 데이터도 제대로 복사가 됨을 확인하였다.
    
    c언어의 구조체 변수간의 대입연산이 잠깐 나왔는대 이부분에 대한 내용이 잘 기억나지 않아 다시한번 개념을 찾아보고 내용을 복습하였다. c언어를 사용하면서 구조체를 쓰는 경우 대입연산이 가능한지 모르고 있었는대 이번 기회를 통해 다시 새길 수 있었다.
    
    배열인덱스 연산자의 경우 연산자 이름이 int operator[] (...)와 같은 형태여서 조금 특이했다. 이 연산자를 사용하는 경우 기존의 배열에서 확인할 수 없는 경계값 검사 등 원하는 내용을 추가로 넣어줄 수 있다는 장점이 있었다. 경계검사를 진행하는 코드에서 exit(1);라는 문장을 보았는대 무엇인지 알지못하였다. 인터넷을 통해 찾아본 결과 메인함수 외에서 프로세스를 종료하는 함수이며 괄호안에 숫자는 오류메세지를 나타내고 메인함수에서 return과 유사하게 사용되는 것임을 알았다. 배열인덱스 연산자에서 const를 이용한 오버로딩의 활용방법에 대해 알게 되었다. 매개변수로 들어온 배열의 값을 변경해야하는 경우와 변경해서는 안되는 경우가 모두 존재하는 경우 const 선언을 추가하여 함수를 오버로딩하여 각각 적용되는 함수를 다르게 해줄 수 있었다.    
       
8. 학습 내용에 대한 개인적인 총평 (최소 5줄 이상) //
    
    계속해서 반환형이 참조자인 함수와 이를 이용한 연산이 나오고 있어 참조자에 대해 저절로 복습이 되는 효과가 있고 어느정도 이해가 되었다.
    
    배열인덱스 연산자 오버로딩에서 const를 이용하여 오버로딩 한 것이 어려웠지만 유용했다. const 선언 역시 오버로딩을 구별해주는 요소가 된다는 것을 확인할 수 있었고 아직까지 안정성을 주는 const 선언을 거의 활용하지 않고 코드를 작성하지만 연습을 통해 const를 사용하며 좀 더 안정성 있는 코드를 연습해 보면 좋을것 같다고 느꼈다.
    
    객체의 저장을 위한 배열 클래스에서 객체의 주소값을 저장하는 배열 클래스와 객체를 직접 저장하는 배열 클래스와의 차이점이 잘 이해가 되지 않았다. 주소값을 저장하는 방식의 경우 arr[0]=new Point(3,4)와 같이 new를 사용해 주었는대 new를 꼭 사용해야하는지 의문이 들었다. 복습을 통해 다시 공부해보면 좋을 것 같다.    
    
9. 다음 학습 계획 (최소 5줄 이상) // 
    
    42seoul 과제 이외에 개인적으로 c++ 에 대해 학습한다.
    
    알고리즘 연습문제를 풀며 학습한다.
    
    libft 코드를 수정하고 평가를 받는다.