1. 학습 날짜 // 

    2020-10-28(수)
 
2. 학습시간 // 

    09:00 ~ 18:00 (자가)
    
3. 학습 범위 및 주제 // 
    
    c, 자료구조, 스택, 큐

4. 동료 학습 방법 (온라인 또는 오프라인으로 동료 학습이 이뤄진 경우, 어떤 식으로 이뤄졌는지 기술) // 오프라인으로 만난경우 각각 슬랙 아이디 // 온라인(슬랙, 스카이프, 카카오톡)으로 피드백을 받는 경우 피드백해준 자 ID // 

    온라인을 통해 동료학습 하였다. 원형 큐에서 큐가 꽉차있는 상태를 확인하는 방식에 대해 알게 되었다. 피드백해준 자 :gicho, jeonkim, sanhan, jungtlee, youcho, sanglee

5. 학습 목표 //

    여러가지 유형의 자료구조를 학습한다.
    
6. 과제 제출 repository 주소 // 
    
    
    
7. 상세 학습 내용 (운영진 판단하에 학습 내용이 부진할 경우 재 제출 요구 예정) 필수사항 이외에 자유롭게 작성 가능 실제 코딩에 사용한 시간 (필수) 학습에 참고한 사이트 (홈페이지, 블로그, 동영상, 자료)와 간단한 내용(권고) 오늘 발견한 문제(버그, 몰랐던 것,...)와 해결 방안(필수) 다른 교육생들과의 협업, 토론 내용(권고) //
    
    09:00 ~ 18:00 동안 연습문제를 풀며 코드를 작성하였다.
    
        int Push_Stack(int data)
        {
            if (Sptr == STACK_FULL) return -1;
            Stack[--Sptr] = data;
            return 1;
        }
        
        int Pop_Stack(int *p)
        {
            if (Sptr == STACK_EMPTY) return -1;
            *p = Stack[Sptr++];
            return 1;
        }
        
        int In_Queue(int data)
        {
            if (Wrptr == Q_FULL) {
                if (Rdptr == Q_EMPTY) return -1;
                for (int i = 0; i < Wrptr - Rdptr; i++) { Queue[i] = Queue[Rdptr+i]; }
                Wrptr = Wrptr - Rdptr;
                Rdptr = 0;
            }
            Queue[Wrptr++] = data;
            return 1;
        }

        int Out_Queue(int *p)
        {
            if (Rdptr == Wrptr) return -1;
            *p = Queue[Rdptr++];
            return 1;
        }
        
        int In_Queue(int data)
        {
            if ((Wrptr + 1) % MAX_Q == Rdptr) return -1;
            Queue[Wrptr] = data;
            Wrptr = (++Wrptr) % MAX_Q;
            return 1;
        }
        
        int Out_Queue(int *p)
        {
            if (Rdptr == Wrptr) return -1;
            *p = Queue[Rdptr];
            Rdptr = (++Rdptr) % MAX_Q;
            return 1;
        }
    
8. 학습 내용에 대한 개인적인 총평 (최소 5줄 이상) //
    
    자료를 저장하는 방식인 스택과 큐에대해 학습하였다. 스택은 후입선출형 구조로 동작하는 자료구조로 마지막에 들어온 자료부터 처리할 때 유용한 방식이다. 스택을 운영하기 위해서는 데이터를 저장하는 공간과 현재 상태를 알려주는 스택포인터가 필요하다. 스택구조는 스택포인터의 위치와 데이터의 인덱스 순서에 따라 ea, ed, fa, fd 4가지 방식으로 나눌수 있다. 스택포인터의 위치와 인덱스 순서를 제외한 나머지 작동 방식은 동일하다. 스택에 데이터를 저장하는 함수는 스택이 꽉 차있는지 확인하는 부분과 데이터를 저장하고 스택포인터를 옮기는 부분으로 구성할 수 있다. 스택에서 데이터를 꺼내는 함수는 스택이 비어있는지 확인하는 부분과 데이터를 꺼내고 스택포인터를 옮기는 부분으로 구성할 수 있다.
    
    큐는 선입선출형 구조로 동작하는 자료구조로 bfs 등 자료를 들어온 순서에 따라 처리할 때 유용한 방식이다. 큐를 운영하기 위해서는 데이터를 저장하는 공간과 데이터를 읽는데 사용하는 read pointer, 데이터를 저장하기 위해 사용하는 write pointer가 필요하다. 큐에 데이터를 저장하는 함수는 큐가 꽉 차있는지 확인하는 부분과 꽉차있지 않은 경우 버퍼를 정리하는 부분으로 구성한다. 선형 큐의 경우 write pointer가 full 상태이더라도 read pointer가 empty 상태가 아니면 앞에 이미 꺼낸 데이터들이 저장되어있는 공간이 존재하므로 이 공간에 데이터를 더 저장할 수 있다. 이런 경우 메모리를 효율적으로 사용하기 위해서 기존의 데이터를 빈공간 만큼 앞으로 옮기고 포인터의 위치를 변경 시켜주어 빈 공간에 데이터를 추가로 저장할 수 있게 만드는 작업이 필요하다.
    
    원형 큐는 버퍼 크기가 작은 경우 데이터의 자료이동이 잦은 선형큐의 단점을 해결하기 위한 것으로 포인터가 버퍼의 처음과 끝을 계속해서 순환하는 방식으로 동작한다. 이 경우 read pointer 와 write pointer의 순서가 바뀔 수 있기 때문에 full 상태를 확인하기 위해서는 항상 버퍼를 1개 비워두고 이를 이용해서 full상태를 확인해야한다. 1개의 버퍼가 낭비되지만 무시가능한 수준이므로 사용할 수 있다. (Wrptr + 1) % MAX_Q == Rdptr 조건으로 full 상태를 판단하고 Wrptr == Rdptr 조건으로 empty 상태를 판단한다.
    
    스택과 큐에 대해 많은 내용을 자세히 배울 수 있었다. 그동안 모르던 내용을 많이 알게 되었으며 알고리즘이나 프로젝트에서 스택과 큐를 자유롭게 사용할 수 있을 것 같다.
    
9. 다음 학습 계획 (최소 5줄 이상) // 
    
    자료구조, 파이썬에 대해 학습한다.
    
    cub3d에 대해 공부하고 평가를 받는다.
    
    c++언어를 복습하며 심화학습한다.