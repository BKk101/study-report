1. 학습 날짜 // 

    2020-04-10(금)

2. 학습시간 // 

    14:00 ~ 17:00, 19:00 ~ 21:00 (자가)

3. 학습 범위 및 주제 // 
    
    c++, 연산자 오버로딩

4. 동료 학습 방법 (온라인 또는 오프라인으로 동료 학습이 이뤄진 경우, 어떤 식으로 이뤄졌는지 기술) // 오프라인으로 만난경우 각각 슬랙 아이디 // 온라인(슬랙, 스카이프, 카카오톡)으로 피드백을 받는 경우 피드백해준 자 ID // 

    온라인을 통해 동료학습 함. 카카오톡 단체 채팅방과 슬랙 random 채널을 이용하여 모르는 부분에 대해 질문하고 답을 얻음. 피드백해준 자 :gicho, jeonkim, sanhan, jungtlee, youcho, sanglee

5. 학습 목표 //

    연산자 오버로딩에 대해 학습한다.
    
6. 과제 제출 repository 주소 // 
    
    gits@git.innovationacademy.kr:bykim/cpp.git
    
7. 상세 학습 내용 (운영진 판단하에 학습 내용이 부진할 경우 재 제출 요구 예정) 필수사항 이외에 자유롭게 작성 가능 실제 코딩에 사용한 시간 (필수) 학습에 참고한 사이트 (홈페이지, 블로그, 동영상, 자료)와 간단한 내용(권고) 오늘 발견한 문제(버그, 몰랐던 것,...)와 해결 방안(필수) 다른 교육생들과의 협업, 토론 내용(권고) //

    19:00 ~ 21:00 동안 연습문제를 풀며 코드를 작성하였다.
    함수의 오버로딩을 이용하여 연산자를 오버로딩하여 기존의 연산자를 다양한 자료형에서 활용할 수 있는 방법을 알았다. 이를 연산자 오버로딩이라고 하며 어떤 클래스 내부에 연산자와 관련된 함수를 오버로딩하여 해당 클래스에 속하는 객체들 간에 기존의 연산자를 이용한 연산을 가능하게 하였다. 
    
    단항연산자의 오버로딩을 알게 되었고 전위연산과 후위연산을 구현하는 방법도 알게 되었다. 후위연산을 구현하는 경우 오버로딩한 함수의 반환형에 const를 선언해 주어 실제 c++문법에 부합하게 (a++)++; 과 같은 형태의 코드가 컴파일에러가 발생하도록 해주었다. 함수의 반환형에 const 선언을 해주는 것이 처음에 쉽게 이해가 가지 않았는대 반환형이 const인 것과 const 함수 선언하는 것을 혼동해서 생긴 문제였다. const 함수 선언의 경우 operator+() const; 와 같이 함수의 마지막에 const를 붙이는 것이나 반환형에 const 선언을 한것을 동일한 것으로 착각하였다.
    
    연산자 오버로딩에서 객체가 가장 왼쪽에 와야하는 제한이 있는대 교환법칙을 해결하기 위해 전역함수 형태로 연산자 오버로딩하여 문제를 해결할 수 있었다. 이때, 전역함수의 내용에 return ref * tims 와 같이 객체와 변수의 순서만 바꿔주는 형식으로 간단히 한줄만으로 작성해줄 수 있었다. 연산자 오버로딩에는 멤버함수를 이용하는 방법과 전역함수를 이용하는 방법이 있었는대 교환법칙을 구현하는 과정에서 전역함수만을 이용해야하는 경우를 알 수 있었다.
       
8. 학습 내용에 대한 개인적인 총평 (최소 5줄 이상) //
    
    연산자 오버로딩에서 연산자와 관련된 함수는 operator+ 같이 'operator' 와 '+' 같이 특정연산자를 결합한 형태로 이름을 짓게되며, 이렇게 해준 경우 pos1 + pos2를 pos1.operator+(pos2)로 인식하는 것이 신기하였다. c++ 기본 규칙에 정의되어 있는 것으로 예상되었다.
    
    후위연산자 오버로딩 함수를 구현하는 과정에서 피신과정때 멘토에게 들었던 내용을 떠올릴 수 있었다. 전위연산과 후위연산의 차이점을 묻는 질문에 제대로 대답하지 못하였고 멘토로 부터 새로운 내용을 많이 배울 수 있었는대, 그 당시 들었던 내용이 다시 나와 이해가 수월했다.
    
    c, c++을 사용하면서 ++(++num); 이나 (num++)++;와 같은 형태의 코드를 사용해본적이 없어 이를 기본으로 허용하는 것인지 알지 못하였다. 이번 기회에 기본적으로 사용가능한 문법이라는 사실을 새롭게 알게되어 좋았다.
    
    클래스를 공부하면서 책에서는 대부분 참조자를 이용하여 표현하였는대 포인터를 이용해도 똑같다고 생각하고 익숙하지 않은 참조자 표현에 대해 제대로 공부하지 않고 넘어갔었다. 그러나 연산자 오버로딩을 공부하며 연속적인 연산자 오버로딩을 사용하기 위해서 참조자를 이용한 표현을 하는 것이 편리한 것을 알게 되었고 참조자에 대해 제대로 익혀야 하는 이유를 찾을 수 있었다.
    
9. 다음 학습 계획 (최소 5줄 이상) // 
    
    42seoul 과제 이외에 개인적으로 c++ 에 대해 학습한다.
    
    알고리즘 연습문제를 풀며 학습한다.
    
    libft 코드를 수정하고 평가를 받는다.