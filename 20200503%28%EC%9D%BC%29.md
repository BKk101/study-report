1. 학습 날짜 // 

    2020-05-03(일)

2. 학습시간 // 

    12:00 ~ 17:00, 19:00 ~ 21:00(자가)

3. 학습 범위 및 주제 // 
    
    b트리, 분할정복법

4. 동료 학습 방법 (온라인 또는 오프라인으로 동료 학습이 이뤄진 경우, 어떤 식으로 이뤄졌는지 기술) // 오프라인으로 만난경우 각각 슬랙 아이디 // 온라인(슬랙, 스카이프, 카카오톡)으로 피드백을 받는 경우 피드백해준 자 ID // 

    온라인을 통해 동료학습 함. 카카오톡 단체 채팅방과 슬랙 random 채널을 이용하여 모르는 부분에 대해 질문하고 답을 얻음. 피드백해준 자 :gicho, jeonkim, sanhan, jungtlee, youcho, sanglee

5. 학습 목표 //

    b트리와 분할정복법에 대해 학습한다.
    
6. 과제 제출 repository 주소 // 
    
    
    
7. 상세 학습 내용 (운영진 판단하에 학습 내용이 부진할 경우 재 제출 요구 예정) 필수사항 이외에 자유롭게 작성 가능 실제 코딩에 사용한 시간 (필수) 학습에 참고한 사이트 (홈페이지, 블로그, 동영상, 자료)와 간단한 내용(권고) 오늘 발견한 문제(버그, 몰랐던 것,...)와 해결 방안(필수) 다른 교육생들과의 협업, 토론 내용(권고) //
    
    20:00 ~ 21:00 동안 연습문제 코드를 작성하였다.
    검색 알고리즘의 하나인 b트리에 대해 배웠다. b트리는 앞서 배웠던 2-3트리, 2-3-4트리의 확장 형태로 방식이 유사하다. 검색 대상 자료가 내부 메모리 같이 접근 속도가 빠른 곳에 위치한 경우를 내부검색이라고 할때, 하드 디스크 같은 외부 기억장치에 검색 대상 자료가 위치한 경우를 외부 검색이라고 한다. 외부 기억장치에 접근 하는 과정은 시간이 매우 많이 소모되기 때문에 한번 접근할 때 블록 또는 페이지라고 불리는 일정한 크기를 가진 단위로 접근한다. b트리는 외부 기억장치에 검색 대상이 존재할때 접근 시간을 줄이기 위해 한 노드에 많은 키값을 저장하여 트리의 높이를 최소화하고 접근횟수를 줄인 구조이다. b트리는 노드가 가질수 있는 키값의 최대 수에 따라 k차 b트리가 존재한다. 이때 k차 b트리는 1) 루트를 제외한 모든 노드는 [k/2] 개 이상 k 개 이하의 키값을 가지고 2) b트리는 항상 균형 상태이며 모든 리프노드는 같은 깊이를 가지는 특징을 만족한다.
    
    b 트리 검색은 키값이 위치한 자식 노드를 찾아가는 방식으로 이진트리, 2-3트리, 2-3-4트리와 동일하다. b트리의 자료 삽입은 2-3-4트리와 유사하게 꽉찬 노드를 만나면 분할을 하면서 내려가고 자료 삭제는 상황에 따라 바로 삭제하거나 b 트리구조를 유지하지 못하는 경우 형제노드와 부모노드를 비교하여 값을 빌리는 방식을 이용하여 트리구조를 유지하면서 삭제를 진행한다.
    
    알고리즘 설계 방법 중 하나인 분할정복법에 대해 배웠다. 분할 정복법은 주어진 문제를 두개 또는 그 이상의 부분 문제로 나누고 나누어진 부분 문제의 답을 각각 구하고 부분문제의 답을 결합하여 처음 문제의 답을 구하는 방식이다. 점화식으로 표현되는 문제들, 재귀적 방법을 이용하여 푸는 문제들이 여기에 해당된다. 앞서 배운 이진탐색의 경우도 전체 검색 대상을 n/2번째 원소를 기준으로 좌측, 중앙, 우측 세가지 부분문제로 나누어 검색을 해나가는 방식으로 분할정복법에 해당한다. 
    
    분할정복방법을 배우면서 꼬리재귀에 대해 알게 되었다. 일반 재귀의 경우 규모가 커지면 함수 호출이 너무 많아지게 되며 스택 오버플로우가 발생할 수 있다. 이를 해결하기 위해 재귀적으로 함수를 호출하지만 값을 리턴하고 나서 작업을 수행하지 않는 형식으로 코드를 작성하는 방식으로 최적화 하여 스택 오버플로우를 방지하는 방법이다. 꼬리 재귀를 사용하기 위해서는 컴파일러에 최적화 기능이 있어야 한다. (참고 사이트 : https://bozeury.tistory.com/entry/%EA%BC%AC%EB%A6%AC-%EC%9E%AC%EA%B7%80-%EC%B5%9C%EC%A0%81%ED%99%94Tail-Recursion)
    
8. 학습 내용에 대한 개인적인 총평 (최소 5줄 이상) //
   
   일정한 크기를 가진 공간에 한 노드가 가질 수 있는 최대 키 값을 구하는 식을 이해하지 못하였다. 키값이 16바이트, 포인터값이 4바이트이고 자식 노드가 위치한 주소를 가리키는 포인터 k+1개, 키값이 위치한 주소를 가리키는 포인터 k개, 부모노드가 위치한 주소를 가리키는 포인터 1개가 필요할때 2(k+1) + 8k + 2 <= 4096이라는 식으로 k = 409를 구하였으나 2와 8 대신 4와 16이 오는 것이 맞지 않나 생각하였다. 여러번 생각해보고 동료에게 질문해 보았으나 답을 찾지 못해서 아쉽다.
   
   b트리의 경우 하나의 노드에 많은 수의 키값을 저장하기때문에 자료를 삽입하거나 삭제하는 과정에서 조건에 따라 방법이 다양하고 분할을 여러번 수행해야하기 때문에 의사코드의 내용이 상당히 길었다. 이것을 보며 완전한 코드로 구현하기가 상당히 힘들것으로 느껴졌다. 
   
   책을 보며 학습하는 과정에서 하나의 개념을 표현하는 용어가 통일되어 있지 않아서 혼란스러웠다. 트리 구조에서 자식노드가 없는 가장 마지막 노드를 나타낼때 외부노드, 리프노드, 단말노드 등 부분마다 다른 용어를 사용하여 어떤 것을 의미하는지 혼동되었고 해당 용어의 의미를 찾아보느라 시간이 걸려 불편했다. 용어를 통일해서 표현하는 것의 중요성을 느꼈다.
   
   분할정복법 단원에서는 분할정복방법을 이용한 여러가지 알고리즘이 소개되어있었다. 수식을 이용한 시간복잡도의 증명과 분할정복방법을 이용하여 구현하는 방법등이 소개되어있었으며 실제로 어떤 코드를 작성하기보다는 개념적인 내용들 위주로 되어있어 조금 아쉬웠다.
   
   이분검색을 공부하면서 꼬리재귀에 대해 알게 되었다. 재귀함수를 이용하면 스택에 누적되어 오버플로우가 발생하거나 시간이 오래걸리는 문제가 발생할 수 있다는 것을 알고 있었으나 이를 최적화하기 위한 방법으로 꼬리재귀가 있다는 것을 처음 알게되었다. 경험적으로 재귀함수 코드를 작성할 때 리턴해서 연산을 수행하지 않는 방식으로 작성한적도 있었으나 책을 통해 제대로 된 개념을 찾아볼수 있어 만족스러웠다.
   
9. 다음 학습 계획 (최소 5줄 이상) // 
    
    42seoul 과제 이외에 개인적으로 알고리즘, 자료구조에 대해 학습한다.
    
    알고리즘 연습문제를 풀며 학습한다.
    
    ft_printf 코드를 수정하고 평가를 받는다.
    